//------------------------------------------------------------------------------------------------//
// This file is part of the Nebula Logger project, released under the MIT License.                //
// See LICENSE file or go to https://github.com/jongpie/NebulaLogger for full license details.    //
//------------------------------------------------------------------------------------------------//

/**
 * @group Logger Engine
 * @description Class used for tracking & parsing stack traces
 * @see Logger
 * @see LogEntryBuilder
 */
public without sharing class LoggerStackTrace {
    private final static String SOURCE_TYPE_APEX_ANONYMOUS_BLOCK = 'ApexAnonymousBlock';
    private final static String SOURCE_TYPE_APEX_CLASS = 'ApexClass';
    private final static String SOURCE_TYPE_APEX_TRIGGER = 'ApexTrigger';
    private final static Set<String> IGNORED_APEX_CLASSES = new Set<String>{ LoggerStackTrace.class.getName() };
    private final static String NEW_LINE_DELIMITER = '\n';

    /**
     * @description The name of the Apex class that generated the stack trace
     */
    public String apexTopLevelClassName { get; private set; }

    /**
     * @description The name of the Apex trigger that generated the stack trace
     */
    public String apexTriggerName { get; private set; }

    /**
     * @description The name of the Apex inner class that generated the stack trace,
     *              or null if the stack trace was generated by a top-level class
     */
    public String apexInnerClassName { get; private set; }

    /**
     * @description The line number of the Apex class that generated the stack trace
     */
    public Integer apexCodeLineNumber { get; private set; }

    /**
     * @description The name of the Apex method that generated the stack trace
     */

    public String apexMethodName { get; private set; }

    /**
     * @description The generated origin the Apex class & method that generated the stack trace, using the formats
     *              MyClass.someMethod, MyClass.MyInnerClass.someMethod, or AnonymousBlock
     */
    public String originLocation { get; private set; }

    /**
     * @description The API name of metadata that generated the stack trace
     */
    public String originSourceApiName { get; private set; }

    /**
     * @description The type of metadata that generated the stack trace
     */
    public String originSourceType { get; private set; }

    /**
     * @description The cleansed version of the platform-generated stack trace. This version has been cleansed
     *              by removing an ignored Apex classes (denoted by using LoggerStackTrace.ignoreOrigin) of the Apex class that generated the stack trace
     */
    public String parsedStackTraceString { get; private set; }

    /**
     * @description Adds the specified Apex type to the list of ignored origin locations for the current transaction.
     *              Any ignored types will be removed from the StackTrace__c field, and will be skipped when determining
     *              the log entry's origin location
     * @param  apexType The Apex type of the class to ignore
     */
    public static void ignoreOrigin(System.Type apexType) {
        IGNORED_APEX_CLASSES.add(apexType.getName());
    }

    /**
     * @description Adds the specified Apex types to the list of ignored origin locations for the current transaction.
     *              Any ignored types will be removed from the StackTrace__c field, and will be skipped when determining
     *              the log entry's origin location
     * @param  apexTypes A `Set` containing the Apex types of the classes to ignore
     */
    public static void ignoreOrigins(Set<System.Type> apexTypes) {
        for (System.Type apexType : apexTypes) {
            ignoreOrigin(apexType);
        }
    }

    /**
     * @description Constructor that automatically generates & parses stack trace information
     *              based on the calling code
     */
    public LoggerStackTrace() {
        this(new System.DmlException());
    }

    /**
     * @description Constructor that parses stack trace information from the provided `Exception`
     * @param  apexException An instance of any `Exception` class
     */
    public LoggerStackTrace(Exception apexException) {
        this(apexException?.getStackTraceString());
    }

    /**
     * @description Constructor that parses stack trace information from the provided `String`
     * @param  apexStackTraceString The original stack trace value generated by the platform
     */
    public LoggerStackTrace(String apexStackTraceString) {
        this.setApexClassDetails(apexStackTraceString);
    }

    private void setApexClassDetails(String apexStackTraceString) {
        if (this.isValidStackTrace(apexStackTraceString) == false) {
            return;
        }

        // In a managed package, we can end up with an invalid (unhelpful) stack trace, so only store when valid
        List<String> cleansedStackTraceLines = this.getCleansedStackTraceLines(apexStackTraceString);
        this.parsedStackTraceString = String.join(cleansedStackTraceLines, NEW_LINE_DELIMITER);
        if (this.isValidStackTrace(this.parsedStackTraceString)) {
            String firstStackTraceLine = cleansedStackTraceLines.get(0);
            String cleanedOriginLocation = firstStackTraceLine;
            if (cleanedOriginLocation.contains(':')) {
                cleanedOriginLocation = cleanedOriginLocation.substringBefore(':');
            }

            // Example anonymous block: AnonymousBlock: line 9, column 1
            // Example class (top-level): Class.ExampleClassWithLogging.throwSomeException: line 25, column 1
            // Example class (inner): Class.ExampleClassWithLogging.SomeInnerClass.doSomethingElse(): line 97, column 1
            // Example trigger: Trigger.SomeTrigger: line 4, column 1
            String apexCodeLineNumberString = firstStackTraceLine.substringAfter('line ').substringBefore(',');
            if (String.isNotBlank(apexCodeLineNumberString) == true) {
                this.apexCodeLineNumber = Integer.valueOf(apexCodeLineNumberString);
            }

            if (cleanedOriginLocation == 'AnonymousBlock') {
                this.originSourceType = SOURCE_TYPE_APEX_ANONYMOUS_BLOCK;
            } else if (cleanedOriginLocation.startsWith('Class.')) {
                this.originSourceType = SOURCE_TYPE_APEX_CLASS;
                cleanedOriginLocation = cleanedOriginLocation.substringAfter('Class.');

                List<String> originLocationPieces = cleanedOriginLocation.split('\\.');
                this.originSourceApiName = originLocationPieces.get(0);
                this.apexTopLevelClassName = originLocationPieces.get(0);
                this.apexInnerClassName = originLocationPieces.size() == 3 ? originLocationPieces.get(1) : null;
                this.apexMethodName = originLocationPieces.size() >= 2 ? originLocationPieces.get(originLocationPieces.size() - 1) : null;
            } else if (cleanedOriginLocation.startsWith('Trigger.')) {
                this.originSourceType = SOURCE_TYPE_APEX_TRIGGER;
                cleanedOriginLocation = cleanedOriginLocation.substringAfter('Trigger.');

                this.originSourceApiName = cleanedOriginLocation;
                this.apexTriggerName = cleanedOriginLocation;
            }

            this.originLocation = cleanedOriginLocation;
        }
    }

    private Boolean isValidStackTrace(String stackTraceString) {
        // Some lines, especially in the managed package, can result in '()' or '(Some_Namespace)'
        if (
            String.isBlank(stackTraceString) == true ||
            stackTraceString == '()' ||
            System.Pattern.compile('^\\([0-9A-Za-z_]+\\)$').matcher(stackTraceString).matches() == true
        ) {
            return false;
        }

        return true;
    }

    private List<String> getCleansedStackTraceLines(String stackTraceString) {
        List<String> stackTraceLines = new List<String>();
        String previousStackTraceLine;
        for (String currentStackTraceLine : stackTraceString.split(NEW_LINE_DELIMITER)) {
            // Duplicate lines are sometimes introduced, so skip the current line if it's the same as the previous line
            if (currentStackTraceLine == previousStackTraceLine) {
                continue;
            }

            // Don't include the logging system's classes in the stack trace
            Boolean ignoreLine = false;
            for (String ignoredApexClass : IGNORED_APEX_CLASSES) {
                if (currentStackTraceLine.contains('.' + ignoredApexClass.trim() + '.')) {
                    ignoreLine = true;
                    continue;
                }
            }
            // Some lines, especially in the managed package, can result in '()' or '(Nebula)'
            if (this.isValidStackTrace(currentStackTraceLine) == false) {
                ignoreLine = true;
            }

            if (ignoreLine == false) {
                previousStackTraceLine = currentStackTraceLine;
                stackTraceLines.add(currentStackTraceLine);
            }
        }

        return stackTraceLines;
    }
}
